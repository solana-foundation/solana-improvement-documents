---
simd: '0387'
title: BLS Pubkey management in vote account
authors:
  - Sam Kim (Anza)
  - Quentin Kniep (Anza)
  - Wen Xu (Anza)
category: Standard
type: Core
status: Review
created: 2025-10-27
feature: (fill in with feature key and github tracking issues once accepted)
---

## Summary

This proposal specifies in detail how a BLS public key can be generated by
users via updated existing tools and how they can put the generated BLS public
keys into their vote accounts for voting in Alpenglow.

It also describes in detail the data structure changes needed.

## Motivation

The Alpenglow SIMD (326) described the new consensus protocol which will be
launched on Solana. The protocol requires efficient and safe aggregation of
validator votes to succinctly prove certain state transitions can safely happen
(for example, 60% of the validators voted to skip a slot). The ed25519
signatures we currently use are not the best fit for this purpose, so instead
we will be using the Boneh–Lynn–Shacham (BLS) aggregate signature scheme to
sign Alpenglow votes.

However, the BLS public key is entirely different from an ed25519 public key
(as BLS operates over a different elliptic curve), so we can’t naively reuse
the current ed25519 public keys in vote accounts either. We have to add a BLS
public key into each vote account and make that a requirement a little before
Alpenglow launches.

## Dependencies

- Alpenglow is specified in [SIMD 326](https://github.com/solana-foundation/solana-improvement-documents/pull/326)

- VoteStateV4 is specified in [SIMD 185](https://github.com/solana-foundation/solana-improvement-documents/pull/185)
and it adds an optional BLS public key field

- Requiring BLS public key for Alpenglow is specified in [SIMD 357](https://github.com/solana-foundation/solana-improvement-documents/pull/357)

## New Terminology

- **BLS public key**: The public key used in BLS signatures. It will be
compressed and stored as a 48 bytes vector in vote account.

## Detailed Design

BLS keypairs can be generated randomly like ed25519 keypairs. But to save the
users some trouble on keypair management, we chose to derive their BLS keypair
used in Alpenglow votes based on their ed25519 vote keypair. In other words,
with an existing ed25519 vote keypair, the users can safely regenerate the
associated BLS keypair on demand.

### User Operations Support

Since a user’s BLS keypair always changes with the vote authority keypair, we
list three different scenarios below. The following are all dependent on the
feature associated with this SIMD being rolled out, the operations will not
change before the feature is active.

1. Creating a new vote account

When users create a new vote account, the correct BLS public key will be
automatically added to the new vote account. The BLS public key is derived
from the vote authority keypair (if authorized voter is not specified, identity
keypair is used).

2. Changing vote authority keypair on existing vote account

When users update the vote authority keypair, the correct BLS public key will
be automatically updated in the vote account. The BLS public key rotation
happens at the same time when a new vote authority switch happens.

3. Updating missing BLS public key on existing vote account

This is a temporary work-around before all existing staked vote accounts have
proper BLS public keys specified. We will add `update-bls-pubkey` command so it
will use the given vote authority keypair to generate and update the BLS public
key in the vote account. When everyone has a proper BLS public key in their
vote accounts this command can be removed.

### Changes to vote program

Whenever a new BLS public key is being updated in the vote account, we need
to perform BLS verification on its validity, see "Security Considerations"
for details. We plan to implement this by calling BLS library from the vote
program, see "Alternatives Considered" for comparison with other solutions.

Since BLS verification is expensive (around 1.15ms), these operations changing
BLS public key will need to have consume 34,500 CU right before BLS signature
verification happens.

Currently the vote program is still using the builtin CU, and each instruction
consumes 3,000 CU. We propose to completely remove the vote program from using
the built in CU. Because simple vote transactions do not use the code path
where the CU limit matters, and there are very few other transactions executed
in the vote program. We can make those transactions consume correct CU based
on the amount of CPU they would consume.

#### Disallow change of vote authority by old instructions

After the feature gate associated with this SIMD is activated, the previous
instructions will be disallowed to change vote authority after off-chain tools
are upgraded, they will result in transaction errors. These include:

```rust
// Will be forbidden after off-chain tools are upgraded, use InitializeAccountV2
InitializeAccount(VoteInit),
// Forbidden when VoteAuthorize is VoteAuthorize::Voter and the account has BLS
// public key
Authorize(Pubkey, VoteAuthorize),
// Forbidden when authorization_type is VoteAuthorize::Voter and the account has
// BLS public key
AuthorizeWithSeed(VoteAuthorizeWithSeedArgs),
// Forbidden when VoteAuthorize is VoteAuthorize::Voter and the account has BLS
// public key
AuthorizeChecked(VoteAuthorize),
// Forbidden when authorization_type is VoteAuthorize::Voter and the account has
// BLS public key
AuthorizeCheckedWithSeed(VoteAuthorizeCheckedWithSeedArgs),
```

#### Add InitializeAccountV2

```rust
InitializeAccountV2(VoteInitV2),
```

```rust
pub const BLS_PUBLIC_KEY_COMPRESSED_SIZE: usize = 48;
pub const BLS_SIGNATURE_COMPRESSED_SIZE: usize = 96;

pub struct VoteInitV2 {
  pub note_pubkey: Pubkey,
  pub authorized_voter: Pubkey,
  pub authorized_voter_bls_pubkey: [u8; BLS_PUBLIC_KEY_COMPRESSED_SIZE],
  pub authorized_voter_bls_proof_of_possession: [u8; BLS_SIGNATURE_COMPRESSED_SIZE],
  pub authorized_withdrawer: Pubkey,
  pub inflation_rewards_commission_bps: u16,
  pub inflation_rewards_collector: Pubkey,
  pub block_revenue_commission_bps: u16,
  pub block_revenue_collector: Pubkey,
}
```

Upon receiving the transaction, the vote program will perform a BLS
verification on submitted BLS public key and associated proof of possession.
The transaction will fail if the verification failed. Otherwise the new vote
account is created with given parameters.

#### Add new variant of VoteAuthorize

```rust
pub struct VoterWithBLSArgs {
    bls_pub_key: [u8; BLS_PUBLIC_KEY_COMPRESSED_SIZE],
    bls_proof_of_possession: [u8; BLS_SIGNATURE_COMPRESSED_SIZE],
}

pub enum VoteAuthorize {
    Voter,
    Withdrawer,
    VoterWithBLS(VoterWithBLSArgs),
}
```

We only allow the new variant in AuthorizeCheck instruction. Calling the new
variant in any other instruction will fail. Upon receiving the AuthorizeCheck
transaction, if the parameter is of the new variant, the vote program will
perform a BLS verification on submitted BLS public key and associated proof of
possession. The transaction will fail if the verification failed. Otherwise the
vote authority change will be recorded in vote account.

## Impact

When starting a validator, the users are supposed to provide all ed25519
keypairs like before. The BLS keypair will automatically be derived from the
vote authority keypair (if that’s missing, then the identity keypair is used
like now). The operations needed to switch the keypair and the operations
needed to switch to a standby node are the same as today.

## Security Considerations

The safety of BLS votes in Alpenglow is still guarded by the ed25519 vote
authority keypair, so users are supposed to safe guard it like before.

We need to have the proof of possession in the instruction inputs so we can
guard against BLS rogue-key attack. If anyone is allowed to randomly choose a
public key, then an attacker can select a particular public key which interacts
with other participants' keys so a forged aggregate signature verifies even
though not all honest parties actually signed.

## Alternatives Considered

### Moving BLS verification to a syscall and/or a different program

The benefit is that it is conceptually cleaner because vote program
does not need to know about any BLS operation, also the BLS syscall and/or
program can be generally used outside the vote program as well.

However, before Alpenglow launches, we still want to keep the vote program
native because it needs to process a lot of vote transactions. Performing
a syscall from a native program adds quite some complexity. Also because it
is a new syscall, we might need to frequently adjust the interface based on
our findings.

Therefore, the current plan is to perform these steps:

1. Directly call the BLS library from the native vote program for the necessary
BLS verification operations.

2. Launch Alpenglow.

3. After Alpenglow launches, add BLS syscall and/or program and move vote
program to BPF.