---
simd: '0387'
title: BLS Pubkey management in vote account
authors:
  - Sam Kim (Anza)
  - Quentin Kniep (Anza)
  - Wen Xu (Anza)
category: Standard
type: Core
status: Review
created: 2025-10-27
feature: (fill in with feature key and github tracking issues once accepted)
---

## Summary

This proposal specifies in detail how a BLS public key can be generated by
users via updated existing tools and how they can put the generated BLS public
keys into their vote accounts for voting in Alpenglow.

It also describes in detail the data structure changes needed.

## Motivation

The Alpenglow SIMD (326) described the new consensus protocol which will be
launched on Solana. The protocol requires efficient and safe aggregation of
validator votes to succinctly prove certain state transitions can safely happen
(for example, 60% of the validators voted to skip a slot). The ed25519
signatures we currently use are not the best fit for this purpose, so instead
we will be using the Boneh–Lynn–Shacham (BLS) aggregate signature scheme to
sign Alpenglow votes.

However, the BLS public key is entirely different from an ed25519 public key
(as BLS operates over a different elliptic curve), so we can’t naively reuse
the current ed25519 public keys in vote accounts either. We have to add a BLS
public key into each vote account and make that a requirement a little before
Alpenglow launches.

## Dependencies

- Alpenglow is specified in [SIMD 326](https://github.com/solana-foundation/solana-improvement-documents/pull/326)

- VoteStateV4 is specified in [SIMD 185](https://github.com/solana-foundation/solana-improvement-documents/pull/185)
and it adds an optional BLS public key field

- Requiring BLS public key for Alpenglow is specified in [SIMD 357](https://github.com/solana-foundation/solana-improvement-documents/pull/357)

## New Terminology

- **BLS public key**: The compressed public key used in BLS signatures. It will
be stored as a 48 bytes vector in vote account.

## Detailed Design

BLS keypairs can be generated randomly like ed25519 keypairs. But to save the
users some trouble on keypair management, we chose to derive their BLS keypair
used in Alpenglow votes based on their ed25519 vote keypair. In other words,
with an existing ed25519 vote keypair, the users can safely regenerate the
associated BLS keypair on demand.

### User Operations Support

Since a user’s BLS keypair always changes with the vote authority keypair, we
list three different scenarios below.

1. Creating a new vote account

After VoteStateV4 (SIMD 185) is enabled everywhere, when users create a new
vote account, the correct BLS public key will be automatically added to the
new vote account. The BLS public key is derived from the vote authority keypair
(if authorized voter is not specified, identity keypair is used).

2. Changing vote authority keypair on existing vote account

After VoteStateV4 (SIMD 185) is enabled everywhere, when users update the vote
authority keypair, the correct BLS public key will be automatically updated in
the vote account. The BLS public key rotation happens at the same time when a
new vote authority switch happens.

3. Updating missing BLS public key on existing vote account

This is a temporary work-around before all existing staked vote accounts have
proper BLS public keys specified. We will add update-bls-pubkey command so it
will use the given vote authority keypair to generate and update the BLS public
key in the vote account. When everyone has a proper BLS public key in their
vote accounts this command can be removed.

### Changes to vote program

Whenever a new BLS public key is being updated in the vote account, we need
to perform BLS verification on its validity, see "Security Considerations"
for details. We plan to implement this by calling BLS library from the vote
program, see "Alternatives Considered" for details.

Since BLS verification is expensive (in the order of ~1 millisecond), these
operations changing BLS public key will need to have correct CU specified to
succeed (actual numbers to be measured and added to this PR).

All of the changes below depend on the launch of VoteStateV4.

#### Disallow change of vote authority by old instructions

After the feature gate associated with this SIMD is activated, the previous
instructions will be disallowed to change vote authority, they will result
in transaction error. These include:

```rust
// Will be totally forbidden, use InitializeAccountV2
InitializeAccount(VoteInit),
// Forbidden when VoteAuthorize is VoteAuthorize::Voter
AuthorizeChecked(VoteAuthorize),
// Forbidden when authorization_type is VoteAuthorize::Voter
AuthorizeCheckedWithSeed(VoteAuthorizeWithSeedArgs),
```

#### Add InitializeAccountV2

```rust
InitializeAccountV2(VoteInitV2),
```

```rust
pub const BLS_PUBLIC_KEY_COMPRESSED_SIZE: usize = 48;
pub const BLS_SIGNATURE_COMPRESSED_SIZE: usize = 96;

pub struct VoteInitV2 {
  pub note_pubkey: Pubkey,
  pub authorized_voter: Pubkey,
  pub authorized_voter_bls_pubkey: [u8; BLS_PUBLIC_KEY_COMPRESSED_SIZE],
  pub authorized_voter_bls_proof_of_possession: [u8; BLS_SIGNATURE_COMPRESSED_SIZE],
  pub authorized_withdrawer: Pubkey,
  pub inflation_rewards_commission_bps: u16,
  pub inflation_rewards_collector: Pubkey,
  pub block_revenue_commission_bps: u16,
  pub block_revenue_collector: Pubkey,
}
```

Upon receiving the transaction, the vote program will perform a BLS
verification on submitted BLS public key and associated proof of
possession. The transaction will fail if the verification failed.
Otherwise the new vote account is created with given parameters.

#### Add new variant of VoteAuthorize

```rust
pub enum VoteAuthorize {
    Voter,
    Withdrawer,
    VoterWithBLS(
      [u8; BLS_PUBLIC_KEY_COMPRESSED_SIZE],  // BLS public key
      [u8; BLS_SIGNATURE_COMPRESSED_SIZE],   // BLS Proof of Posession
    ),
}
```

We only allow the new variant in AuthorizeCheck instruction. Calling the new
variant in any other instruction will fail. Upon receiving the AuthorizeCheck
transaction, if the parameter is of the new variant, the vote program will
perform a BLS verification on submitted BLS public key and associated proof of
possession. The transaction will fail if the verification failed. Otherwise the
vote authority change will be recorded in vote account.

## Impact

When starting a validator, the users are supposed to provide all ed25519
keypairs like before. The BLS keypair will automatically be derived from the
vote authority keypair (if that’s missing, then the identity keypair is used
like now). The operations needed to switch the keypair and the operations
needed to switch to a standby node are the same as today.

## Security Considerations

The safety of BLS votes in Alpenglow is still guarded by the ed25519 vote
authority keypair, so users are supposed to safe guard it like before.

We need to have the proof of possession in the instruction inputs so we can
guard against BLS rogue-key attack. If anyone is allowed to randomly choose a
public key, then an attacker can select a particular public key which interacts
with other participants' keys so a forged aggregate signature verifies even
though not all honest parties actually signed.

## Alternatives Considered

### Moving BLS verification to a syscall and/or a different program

The benefit of this approach is conceptually cleaner because vote program
does not need to know about any BLS operation, also the BLS syscall and/or
program can be generally used outside the vote program as well.

However, before Alpenglow launches, we still want to keep the vote program
native because it needs to process a lot of vote transactions. Performing
a syscall from a native program adds quite some complexity. Also because it
is a new syscall, we might need to frequently adjust the interface based on
our findings.

Therefore, the current plan is to perform these steps:

1. Directly call the BLS library from the native vote program for the necessary
BLS verification operations.

2. Launch Alpenglow.

3. After Alpenglow launches, add BLS syscall and/or program and move vote
program to BPF.