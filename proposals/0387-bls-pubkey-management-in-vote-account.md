---
simd: '0387'
title: BLS Pubkey management in vote account
authors:
  - Sam Kim (Anza)
  - Quentin Kniep (Anza)
  - Wen Xu (Anza)
category: Standard
type: Core
status: Review
created: 2025-10-27
feature: (fill in with feature key and github tracking issues once accepted)
---

## Summary

This proposal specifies in detail how a BLS public key can be generated by
users via updated existing tools and how they can put the generated BLS public
keys into their vote accounts for voting in Alpenglow per [SIMD 326](https://github.com/solana-foundation/solana-improvement-documents/pull/326)

It also describes in detail the data structure changes needed.

## Motivation

The Alpenglow SIMD (326) described the new consensus protocol which will be
launched on Solana. The protocol requires efficient and safe aggregation of
validator votes to succinctly prove certain state transitions can safely happen
(for example, 60% of the validators voted to skip a slot). The ed25519
signatures we currently use are not the best fit for this purpose, so instead
we will be using the Boneh–Lynn–Shacham (BLS) aggregate signature scheme to
sign Alpenglow votes.

However, the BLS public key is entirely different from an ed25519 public key
(as BLS operates over a different elliptic curve), so we can’t naively reuse
the current ed25519 public keys in vote accounts either. We have to add a BLS
public key into each vote account and make that a requirement a little before
Alpenglow launches per [SIMD 357](https://github.com/solana-foundation/solana-improvement-documents/pull/357).

## New Terminology

- **BLS public key**: The public key used in BLS signatures. Its size is 48
bytes in vote accounts, the field name is bls_pubkey_compressed (we will
uncompress it later into 96 bytes, but that’s internal implementation details).

## Detailed Design

BLS keypairs can be generated randomly like ed25519 keypairs. But to save the
users some trouble on keypair management, we chose to derive their BLS keypair
used in Alpenglow votes based on their ed25519 vote keypair. In other words,
with an existing ed25519 vote keypair, the users can safely regenerate the
associated BLS keypair on demand.

### User Operations Support

Since a user’s BLS keypair always changes with the vote authority keypair, we
list three different scenarios below.

1. Creating a new vote account

After VoteStateV4 (SIMD 185) is enabled everywhere, when users use
create-vote-account to create a new vote account, the correct BLS public key
will be automatically added to the new vote account. The BLS public key is
derived from the vote authority keypair (if authorized-voter is not specified,
identity keypair is used).

2. Changing vote authority keypair on existing vote account

After VoteStateV4 (SIMD 185) is enabled everywhere, when users use
vote-authorize-voter-checked to update vote authority keypair, the correct BLS
public key will be automatically updated in the vote account. The BLS public
key rotation happens at the same time when a new vote authority switch happens.

3. Updating missing BLS public key on existing vote account

This is a temporary work-around before all existing staked vote accounts have
proper BLS public keys specified. We will add update-bls-pubkey command so it
will use the given vote authority keypair to generate and update the BLS public
key in the vote account. When everyone has a proper BLS public key in their
vote accounts this command can be removed.

### New instructions to vote programs

In the following instructions, there is a proof_of_knowledge field associated
with the new BLS public key. Since we need to verify the caller really holds
the BLS public key claimed, the caller needs to prove possession of the BLS
keypair to the vote program by signing the BLS public key with the
corresponding BLS keypair. Then the vote program can do a syscall to actually
verify the validity of BLS public key. If the verification fails, the
transaction will fail.

Since BLS verification is expensive (in the order of ~1 millisecond), these
operations changing BLS public key will need to have correct CU specified to
succeed (actual numbers to be measured and published later).

We will be adding the following three instructions:

```rust
pub enum VoteInstruction {
  InitializeAccountWithBLS(VoteInitWithBLS),
  AuthorizeCheckedWithBLS(VoteAuthorizeWithBLS),
  AuthorizeCheckedWithSeedAndBLS(VoteAuthorizeCheckedWithSeedAndBLS)
}
```

- InitializeAccountWithBLS(VoteInitWithBLS)

The main difference between this and InitializeAccount is that VoteInitWithBLS
will contain a new field in addition to the ones in VoteInit:

```rust

/// Size of a BLS signature in a compressed point representation
pub const BLS_SIGNATURE_COMPRESSED_SIZE: usize = 96;

pub struct VoteInitWithBLS {
    pub node_pubkey: Pubkey,
    pub authorized_voter: Pubkey,
    pub authorized_withdrawer: Pubkey,
    pub commission: u8,
    pub bls_pubkey_compressed: [u8; BLS_PUBLIC_KEY_COMPRESSED_SIZE],
    // signing bls_pubkey with bls keypair
    pub proof_of_knowledge: pub  [u8; BLS_SIGNATURE_COMPRESSED_SIZE],
}
```

In addition to the original checks, it also checks that proof of knowledge is
correctly signed.

- AuthorizeCheckedWithBLS(VoteAuthorizeWithBLS)

Changing the vote authority public key and BLS public key for existing vote
account without using seed: (we can also use it to add BLS public key to
existing vote account, just check vote authority public key didn’t change)

```rust
pub enum VoteAuthorizeWithBLS {
    Voter(bls_pubkey_compressed, proof_of_knowledge),
    Withdrawer,
}
```

- AuthorizeCheckedWithSeedAndBLS(VoteAuthorizeCheckedWithSeedAndBLS)

Changing the vote authority public key and BLS public key for existing vote
account using seed: (we can also use it to add BLS public key to existing vote
account, just check vote authority public key didn’t change)

```rust
pub struct VoteAuthorizeCheckedWithSeedAndBLS {
    pub authorization_type: VoteAuthorizeWithBLS,
    pub current_authority_derived_key_owner: Pubkey,
    pub current_authority_derived_key_seed: String,
    pub new_authority: Pubkey,
}
```

## Impact

When starting a validator, the users are supposed to provide all ed25519
keypairs like before. The BLS keypair will automatically be derived from the
vote authority keypair (if that’s missing, then the identity keypair is used
like now). The operations needed to switch the keypair and the operations
needed to switch to a standby node are the same as today.

## Security Considerations

The safety of BLS votes in Alpenglow is still guarded by the ed25519 vote
authority keypair, so users are supposed to safe guard it like before.

We need to have the proof of knowledge in the instruction inputs so we can
guard against BLS rogue-key attack. If you allow anyone to randomly choose a
public key, then the attacker can select a particular key which interacts with
other participants' keys so a forged aggregate signature verifies even though
not all honest parties actually signed.

## Alternatives Considered

We could randomly generate a new BLS keypair, it does mean users need to
separately maintain another different format of keypair. So we are deriving
the BLS keypair from the existing ed25519 keypair.