---
simd: '0387'
title: BLS Pubkey management in vote account
authors:
  - Sam Kim (Anza)
  - Quentin Kniep (Anza)
  - Wen Xu (Anza)
category: Standard
type: Core
status: Review
created: 2025-10-27
feature: (fill in with feature key and github tracking issues once accepted)
---

## Summary

This proposal specifies in detail how a BLS public key can be generated by
users via updated existing tools and how they can put the generated BLS public
keys into their vote accounts for voting in Alpenglow.

It also describes in detail the data structure changes needed.

## Motivation

The Alpenglow SIMD (326) described the new consensus protocol which will be
launched on Solana. The protocol requires efficient and safe aggregation of
validator votes to succinctly prove certain state transitions can safely happen
(for example, 60% of the validators voted to skip a slot). The ed25519
signatures we currently use are not the best fit for this purpose, so instead
we will be using the Boneh–Lynn–Shacham (BLS) aggregate signature scheme to
sign Alpenglow votes.

However, the BLS public key is entirely different from an ed25519 public key
(as BLS operates over a different elliptic curve), so we can’t naively reuse
the current ed25519 public keys in vote accounts either. We have to add a BLS
public key into each vote account and make that a requirement a little before
Alpenglow launches.

## Dependencies

- Alpenglow is specified in [SIMD 326](https://github.com/solana-foundation/solana-improvement-documents/pull/326)

- VoteStateV4 is specified in [SIMD 185](https://github.com/solana-foundation/solana-improvement-documents/pull/185)
and it adds an optional BLS public key field

- Requiring BLS public key for Alpenglow is specified in [SIMD 357](https://github.com/solana-foundation/solana-improvement-documents/pull/357)

## New Terminology

- **BLS public key**: The public key used in BLS signatures. It will be
compressed and stored as a 48-byte array in vote account.

## Detailed Design

BLS keypairs can be generated randomly like ed25519 keypairs. But to save the
users some trouble on keypair management, we chose to derive their BLS keypair
used in Alpenglow votes based on their ed25519 vote keypair. In other words,
with an existing ed25519 vote keypair, the users can safely regenerate the
associated BLS keypair on demand.

When users create vote accounts, they must register their BLS public key by
storing it in the newly created vote account. When they modify their vote
authority, they must re-register the new corresponding BLS key.

### Changes to vote program

Whenever a new BLS public key is being updated in the vote account, we need
to perform BLS verification on its validity, see "Security Considerations"
for details. We plan to implement this by calling BLS library from the vote
program, see "Alternatives Considered" for comparison with other solutions.

Since BLS verification is expensive (around 1.15ms), each verification will cost
34,500 CUs. Any Vote program instruction that performs a BLS verification will
therefore add 34,500 CUs per verification on top of its baseline cost. As a result,
Vote program instructions - which currently all cost 2,100 CUs - will have
differentiated CU costs depending on whether they include BLS verification. The
updated CU values are detailed in later sections.

Note the 34,500 CUs for BLS verification will be consumed immediately before
the verification is performed.

Currently the vote program is allocated a budget of 3,000 CUs in the validator's
builtin program cost modeling mechanism. Simple vote transactions (containing a
`Vote` instruction) already bypass this mechanism, and other Vote program
instructions that may use BLS verification are fairly infrequent. As a result,
the Vote program will be removed from builtin program cost modeling.

#### Disallow change of vote authority by old instructions

After the feature gate associated with this SIMD is activated, the previous
instructions will be disallowed to change vote authority after off-chain tools
are upgraded, they will result in transaction errors. These include:

```rust
// Will be forbidden after off-chain tools are upgraded, use InitializeAccountV2
InitializeAccount(VoteInit),
// Forbidden when VoteAuthorize is VoteAuthorize::Voter and the account has BLS
// public key
Authorize(Pubkey, VoteAuthorize),
// Forbidden when authorization_type is VoteAuthorize::Voter and the account has
// BLS public key
AuthorizeWithSeed(VoteAuthorizeWithSeedArgs),
// Forbidden when VoteAuthorize is VoteAuthorize::Voter and the account has BLS
// public key
AuthorizeChecked(VoteAuthorize),
// Forbidden when authorization_type is VoteAuthorize::Voter and the account has
// BLS public key
AuthorizeCheckedWithSeed(VoteAuthorizeCheckedWithSeedArgs),
```

#### Add InitializeAccountV2

```rust
InitializeAccountV2(VoteInitV2),
```

```rust
pub const BLS_PUBLIC_KEY_COMPRESSED_SIZE: usize = 48;
pub const BLS_SIGNATURE_COMPRESSED_SIZE: usize = 96;

pub struct VoteInitV2 {
  pub note_pubkey: Pubkey,
  pub authorized_voter: Pubkey,
  pub authorized_voter_bls_pubkey: [u8; BLS_PUBLIC_KEY_COMPRESSED_SIZE],
  pub authorized_voter_bls_proof_of_possession: [u8; BLS_SIGNATURE_COMPRESSED_SIZE],
  pub authorized_withdrawer: Pubkey,
  pub inflation_rewards_commission_bps: u16,
  pub inflation_rewards_collector: Pubkey,
  pub block_revenue_commission_bps: u16,
  pub block_revenue_collector: Pubkey,
}
```

Upon receiving the transaction, the vote program will perform a BLS
verification on submitted BLS public key and associated proof of possession.
The transaction will fail if the verification failed. Otherwise the new vote
account is created with given parameters.

#### Add new variant of VoteAuthorize

```rust
pub struct VoterWithBLSArgs {
    bls_pub_key: [u8; BLS_PUBLIC_KEY_COMPRESSED_SIZE],
    bls_proof_of_possession: [u8; BLS_SIGNATURE_COMPRESSED_SIZE],
}

pub enum VoteAuthorize {
    Voter,
    Withdrawer,
    VoterWithBLS(VoterWithBLSArgs),
}
```

We only allow the new variant in AuthorizeCheck instruction. Calling the new
variant in any other instruction will fail. Upon receiving the AuthorizeCheck
transaction, if the parameter is of the new variant, the vote program will
perform a BLS verification on submitted BLS public key and associated proof of
possession. The transaction will fail if the verification failed. Otherwise the
vote authority change will be recorded in vote account.

## Impact

When starting a validator, the users are supposed to provide all ed25519
keypairs like before. The BLS keypair will automatically be derived from the
vote authority keypair (if that’s missing, then the identity keypair is used
like now). The operations needed to switch the keypair and the operations
needed to switch to a standby node are the same as today.

## Security Considerations

The safety of BLS votes in Alpenglow is still guarded by the ed25519 vote
authority keypair, so users are supposed to safe guard it like before.

We need to have the proof of possession in the instruction inputs so we can
guard against BLS rogue-key attack. If anyone is allowed to randomly choose a
public key, then an attacker can select a particular public key which interacts
with other participants' keys so a forged aggregate signature verifies even
though not all honest parties actually signed.

## Alternatives Considered

### Moving BLS verification to a syscall and/or a different program

Another option is we can put BLS verification into a separate program or
into a syscall.

We choose not to do this now because currently vote program needs to handle
a lot of vote transactions so it's a native program. We may explore this
option later if the vote program is migrated to an on-chain BPF program after
Alpenglow launches.