name: Require Jump + Anza approval

# ────── trigger on every meaningful PR event ──────
on:
  pull_request:
    types: [opened, reopened, synchronize, ready_for_review, converted_to_draft]
  pull_request_review:
    types: [submitted, dismissed, edited]

# built-in token is enough (repo-only API)
permissions:
  contents: read
  pull-requests: read

jobs:
  check:
    runs-on: ubuntu-latest
    steps:
      - name: Verify Jump + Anza approvals
        uses: actions/github-script@v7
        with:
          script: |
            // <-- globals github, context, core are injected by github-script -->

            // ──────── 1. MANUAL ROSTERS – edit as needed ────────
            const jumpApprovers = ['jacobcreech', 'topointon-jump', '0x0ece'];
            const anzaApprovers = ['benhawkins18', 'tigarcia', 't-nelson', 'sakridge'];
            // ─────────────────────────────────────────────────────

            const pr = context.payload.pull_request;
            if (!pr) {
              core.setFailed('No pull_request context'); return;
            }

            // 2. pull every review on this PR
            const { data: reviews } = await github.rest.pulls.listReviews({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number,
              per_page: 100
            });

            // ──────── DEBUG BLOCK #1 – raw reviews ────────
            core.info('=== Raw review events ===');
            reviews.forEach(r =>
              core.info(`${r.user.login} -> ${r.state} @ ${r.submitted_at}`));
            // ───────────────────────────────────────────────

            // 3. collapse to effective state per reviewer
            const states = {};              // login → {approved, changesRequested}
            for (const r of reviews) {
              const u = r.user.login;
              states[u] = states[u] || { approved: false, changesRequested: false };
              if (r.state === 'APPROVED')           states[u].approved = true;
              if (r.state === 'REQUEST_CHANGES')    states[u].changesRequested = true;
            }

            // ──────── DEBUG BLOCK #2 – latest state map ────────
            core.info('=== Effective state per reviewer ===');
            Object.entries(states).forEach(([u, s]) =>
              core.info(`${u}: approved=${s.approved}, changesRequested=${s.changesRequested}`));
            // ───────────────────────────────────────────────────

            const approved = Object.entries(states)
                                   .filter(([_, s]) => s.approved && !s.changesRequested)
                                   .map(([u]) => u);

            // ──────── DEBUG BLOCK #3 – final approved list ────────
            core.info(`Approved reviewers counted: ${approved.join(', ') || 'none'}`);
            // ───────────────────────────────────────────────────────

            const hasJump = jumpApprovers.some(u => approved.includes(u));
            const hasAnza = anzaApprovers.some(u => approved.includes(u));

            // 4. nice summary in the PR “Checks” view
            core.summary
                .addHeading('Jump + Anza approval check')
                .addTable([
                  ['Jump approval', hasJump ? '✅' : '❌'],
                  ['Anza approval', hasAnza ? '✅' : '❌']
                ])
                .write();

            if (!hasJump || !hasAnza) {
              core.setFailed('Need at least one Jump and one Anza approval');
            } else {
              core.notice('All required approvals present; merge allowed.');
            }
